{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"[404]","date":"2019-03-07T10:03:52.451Z","updated":"2019-03-07T10:03:52.451Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"about","date":"2019-03-07T10:02:09.633Z","updated":"2019-03-07T10:02:09.633Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"python(一)","slug":"python(1)","date":"2018-05-22T07:35:09.000Z","updated":"2018-05-22T07:37:08.000Z","comments":true,"path":"2018/05/22/python(1)/","link":"","permalink":"http://yoursite.com/2018/05/22/python(1)/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"设计模式","slug":"Éè¼ÆÄ£Ê½","date":"2018-01-08T11:34:27.000Z","updated":"2018-01-08T11:39:04.000Z","comments":true,"path":"2018/01/08/Éè¼ÆÄ£Ê½/","link":"","permalink":"http://yoursite.com/2018/01/08/Éè¼ÆÄ£Ê½/","excerpt":"备忘录模式","text":"备忘录模式 定义:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 备忘录模式的结构发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。 备忘录：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。 管理角色：对备忘录进行管理，保存和提供备忘录。 为什么要捕获这个对象的内部状态？捕获这个内部状态有什么用？ 是为了在以后某个时候，将该对象的状态恢复到备忘录所保存的状态，这才是备忘录真正的目的。前面保存的状态就是为了后面恢复，虽然不是一定要恢复，但是目的是为了恢复。 备忘录模式在js中经常用于数据缓存. 比如一个分页控件, 从服务器获得某一页的数据后可以存入缓存。以后再翻回这一页的时候，可以直接使用缓存里的数据而无需再次请求服务器。12345678910111213141516var Page = function()&#123; var page = 1, cache = &#123;&#125;, data; return function( page )&#123; if ( cache[ page ] )&#123; data = cache[ page ]; render( data ); &#125;else&#123; Ajax.send( &apos;XXX&apos;, function( data )&#123; cache[ page ] = data; render( data ); &#125;) &#125; &#125;&#125; PHP123456789101112131415161718192021222324//游戏角色class GameRole&#123; //游戏角色状态属性（生命力、攻击力、防御力） public $liveLevel; public $attackLevel; public $defenseLevel; #endregion //保存状态 public function SaveState() &#123; return (new RoleStateMemento($this-&gt;liveLevel,$this-&gt;attackLevel,$this-&gt;defenseLevel)); &#125; //恢复状态 public function RecoveryState(RoleStateMemento $_memento) &#123; $this-&gt;liveLevel = $_memento-&gt;liveLevel; $this-&gt;attackLevel = $_memento-&gt;attackLevel; $this-&gt;defenseLevel = $_memento-&gt;defenseLevel; &#125; 优点：1、有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。 2、本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。 缺点：1、如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。 2、当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。 var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"备忘录模式","slug":"备忘录模式","permalink":"http://yoursite.com/categories/备忘录模式/"}],"tags":[]},{"title":"Blog usage","slug":"hello-world","date":"2017-11-18T16:05:12.000Z","updated":"2019-03-07T10:12:25.714Z","comments":true,"path":"2017/11/19/hello-world/","link":"","permalink":"http://yoursite.com/2017/11/19/hello-world/","excerpt":"1 Usage","text":"1 Usage 2Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[],"tags":[]},{"title":"Vue-Echarts","slug":"ECharts","date":"2017-10-03T03:42:52.000Z","updated":"2019-03-07T10:28:13.131Z","comments":true,"path":"2017/10/03/ECharts/","link":"","permalink":"http://yoursite.com/2017/10/03/ECharts/","excerpt":"ECharts 在 Vue 环境下的基础入门","text":"ECharts 在 Vue 环境下的基础入门 ECharts 在 Vue 环境下的引入方式首先需要在 Vue-cli 环境下安装 echarts: 1npm install echarts --save ECharts 不像 element-ui 那样可以直接使用 Vue.use(ElementUI)的引入方式,ECharts 和 axios 一样,需要用继承的 引入方式: 12Vue.prototype.$http = axiosVue.prototype.echarts = echarts 上述这种引入方式是把所有的 charts 包都加载进来,不建议使用,普遍的引入方式是在.Vue 文件内即需即引: 12345678910111213141516171819202122// 引入 ECharts 主模块let echarts = require('echarts/lib/echarts')// 引入柱状图组件require('echarts/lib/chart/bar')// 引入园状图组件require('echarts/lib/chart/pie')// 引入提示框和title组件require('echarts/lib/component/tooltip')require('echarts/lib/component/title')export default &#123; name: 'HelloWorld', data () &#123; return &#123; &#125; &#125;, mounted()&#123; &#125;&#125; charts 简单入门例子一:templter 内需要 charts 建一个有固定宽高的 div 来接受表单,并绑定 id 名 12&lt;div id=\"myChart\"&gt;&lt;/div&gt;//柱状图&lt;div id=\"myChart2\"&gt;&lt;/div&gt;//圆状图 二:引入 charts 各组件 12345678910&lt;script&gt;// 引入 ECharts 主模块let echarts = require('echarts/lib/echarts')// // 引入柱状图组件require('echarts/lib/chart/bar')require('echarts/lib/chart/pie')// // 引入提示框和title组件require('echarts/lib/component/tooltip')require('echarts/lib/component/title')&lt;/script&gt; 三:调用 echarts.init 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051export default &#123; name: 'HelloWorld', data () &#123; return &#123; opp:&#123; series : [ &#123; name: '访问来源', type: 'pie', radius: '55%', roseType: 'angle', data:[ &#123;value:235, name:'视频广告'&#125;, &#123;value:274, name:'联盟广告'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:335, name:'直接访问'&#125;, &#123;value:400, name:'搜索引擎'&#125; ] &#125; ]&#125;, oppos:&#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125; &#125; &#125;, mounted()&#123; let myChart = echarts.init(document.getElementById('myChart')) myChart.setOption( this.oppos 柱状调用 ); let myChart2= echarts.init(document.getElementById('myChart2')) myChart2.setOption( this.opp //圆状调用 ); &#125;&#125; var gitment = new Gitment({ owner: 'fistsea', //比如我的叫anTtutu repo: 'fistsea.github.io/', //比如我的叫anTtutu.github.io oauth: { client_id: '0e27960618be3f7b656a', //比如我的828*********** client_secret: 'bd5466810fa91e3506da0b2c9ea142c9129cf59a', }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Echarts","slug":"Vue/Echarts","permalink":"http://yoursite.com/categories/Vue/Echarts/"}],"tags":[]},{"title":"Vue组件","slug":"Vue-×é¼þ2","date":"2017-10-01T03:42:52.000Z","updated":"2017-12-27T03:49:06.000Z","comments":true,"path":"2017/10/01/Vue-×é¼þ2/","link":"","permalink":"http://yoursite.com/2017/10/01/Vue-×é¼þ2/","excerpt":"父组件调用子组件的方法","text":"父组件调用子组件的方法 比如说,我在子组件中写了一堆的数据表格等动态标签,这些标签内容是由用户填写,好比 input标签等.然而需求是点击父组件中的一个按钮,然后获取用户填写的内容,这时候就用到 了$refs方法.具体用法如下: 子组件命名方法123456methods: &#123; // 保存信息方法 message: function() &#123; console.log(this.List); &#125; &#125;, 父组件调用子组件方法12//父组件写子组件标签是,用ref绑定一个自命名函数&lt;per-son class=\"perSonWrap\" ref=\"update\"&gt;&lt;/per-son&gt; 123456789methods:&#123; //触发Cation2时调用this.$refs.update.message() Cation2:function()&#123; this.$refs.update.message() &#125; &#125; 可以发现,List的数据内容已经console出.从而可以在父组件保存用户数据. var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue组件","slug":"Vue/Vue组件","permalink":"http://yoursite.com/categories/Vue/Vue组件/"}],"tags":[]},{"title":"Vue(八)","slug":"Vue-°Ë","date":"2017-09-25T13:17:39.000Z","updated":"2017-11-27T11:58:44.000Z","comments":true,"path":"2017/09/25/Vue-°Ë/","link":"","permalink":"http://yoursite.com/2017/09/25/Vue-°Ë/","excerpt":"Vue 数组有哪些变异/非变异方法？","text":"Vue 数组有哪些变异/非变异方法？ 变异方法12345678910111213push() //往数组最后面添加一个元素，成功返回当前数组的长度pop() //删除数组的最后一个元素，成功返回删除元素的值shift() //删除数组的第一个元素，成功返回删除元素的值unshift() //往数组最前面添加一个元素，成功返回当前数组的长度splice() //有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除后想要在原位置替换的值（可选）sort() //使数组按照字符编码默认从小到大排序,成功返回排序后的数组reverse() //将数组倒序，成功返回倒序后的数组 这些是和js的操作方法是一致的,会改变被这些方法调用的原始数组. 非变异方法filter(), concat() 和 slice()这些都是非变异方法,是在不改动原始数组的情况下,返回一个新数组. 12345computed:&#123; conat:function()&#123; return this.eating=this.eating.conat(this.c) &#125;&#125; 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 1:当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 2:当你修改数组的长度时，例如：vm.items.length = newLength 单向数据流单向数据流指只能从一个方向来修改状态. 给这句话举个最简单的例子,比如父子组件间的props就是单向数据流,子组件修改props的内容,并不 会引起父组件传给props的值得改变. 子组件修改props:1、定义一个局部变量，并用 prop 的值初始化它。2、定义一个计算属性，处理 prop 的值并返回 123456data() &#123; return &#123; initCount: this.count &#125; &#125;,props: ['count'], var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue(七)","slug":"Vue-Æß","date":"2017-09-21T17:34:31.000Z","updated":"2017-11-23T07:13:22.000Z","comments":true,"path":"2017/09/22/Vue-Æß/","link":"","permalink":"http://yoursite.com/2017/09/22/Vue-Æß/","excerpt":"渲染数组(value list)和对象的键值对(key value pair)以及排序","text":"渲染数组(value list)和对象的键值对(key value pair)以及排序 v-for 渲染数组(value list)v-for 指令需要以 item in items 形式的特殊语法，items 是源数据数组并且item是数组元素迭代的别名。 模板: 1&lt;li v-for=\"item in items\"&gt; &#123;&#123;item&#125;&#125;&lt;/li&gt; js: 12345678910111213export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: &#123; a:'父传子a', b:'父传子2' &#125;, items:[1,2,4,3,6,5] &#125; &#125;, 数组排序js:12345678910computed:&#123; sortItems:function()&#123; //sortItems为自定义变量,要替换模板的items return this.items.sort(this.sortNumber) &#125; &#125;, methods:&#123; sortNumber:function (a,b)&#123; return a-b &#125; &#125;, a,b表示数组中的任意两个元素，若return &gt; 0 b前a后；reutrn &lt; 0 a前b后,a-b表示从小到大排列. 模板: 123&lt;ul&gt; &lt;li v-for=\"item in sortItems\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt; v-for 渲染对象的键值对(key value pair)对象的渲染和数组一样,不同的点在于对象的写法和读取.为了和数组的区别,我们下边把数组的也写上. 123456items:[1,2,4,34,6,5],//数组eating:[ //对象 &#123;name:'苹果',chopper:'2斤'&#125;, &#123;name:'香蕉',chopper:'3斤'&#125;, &#123;name:'橘子',chopper:'4斤'&#125;,] 模板: 12345&lt;ul&gt; &lt;li v-for=\"eat in eating\"&gt; &#123;&#123;eat.name&#125;&#125; - &#123;&#123;eat.chopper&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 加入索引序号： 12345&lt;ul&gt; &lt;li v-for=\"(eat,index) in eating\"&gt; &#123;&#123;index+1&#125;&#125;: &#123;&#123;eat.name&#125;&#125; - &#123;&#123;eat.chopper&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 对象排序数字数组进行a-b比较大小时,可以直接计算,而数组对象进行排序则需要对象里的一个变量进行比较,如下,是用eating.chopper来进行比较的. 需要注意的是排序时的模板eating需要换成sortEating 12345&lt;ul&gt; &lt;li v-for=\"(eat,index) in sortEating\"&gt; &#123;&#123;index+1&#125;&#125;: &#123;&#123;eat.name&#125;&#125; - &#123;&#123;eat.chopper&#125;&#125; &lt;/li&gt; &lt;/ul&gt; js: 1234567891011121314151617181920212223242526 computed:&#123; sortItems:function()&#123; return this.items.sort(this.sortNumber) &#125;, sortEating:function()&#123; //数组对象 return this.sortEat(this.eating,'chopper') &#125; &#125;, methods:&#123; sortNumber:function (a,b)&#123; return b-a &#125;, sortEat:function(array,key)&#123; return array.sort(function(a,b)&#123; var x=a[key]; console.log(a[key]) var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); &#125;); &#125; &#125;, &#125; var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue 组件","slug":"Vue-×é¼þ","date":"2017-09-19T17:26:01.000Z","updated":"2017-11-21T15:36:28.000Z","comments":true,"path":"2017/09/20/Vue-×é¼þ/","link":"","permalink":"http://yoursite.com/2017/09/20/Vue-×é¼þ/","excerpt":"组件的配置使用及父组件向子组件传参","text":"组件的配置使用及父组件向子组件传参 组件的配置和使用组件的作用就是在可以复用，想在那个页面使用都可以，并且像写html标签一样简单. 首先我们需要在components下建立commont文件夹,并在ommont文件夹内建立package.vue, package.vue:12345678910111213141516171819&lt;template&gt; &lt;div class=\"pack-age\"&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; name: 'packAge', data () &#123; return &#123; msg:\"我是组件\" &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; &lt;/style&gt; 在HelloWorld.vue中引入组件: 1import packAge from '@/components/commont/packAge' template内引入组件: 1&lt;packAge&gt;&lt;/packAge&gt; 需要注意的是,组件命名时使用驼峰命名法,vue会把pack-age自动转换成packAge的形式. 父组件向子组件的传参父组件向子组件传参需要用props来传参: 1:首先在子组件定义一个属性用props来接收参数: 123456789export default &#123; name: 'packAge', props: ['meg'] , data () &#123; return &#123; &#125; &#125;&#125; 2:在父组件中的子组件标签中绑定定义的属性,并把要传递的值赋予该属性. 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;packAge v-bind:meg=\"msg\"&gt;&lt;/packAge&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import packAge from '@/components/commont/packAge'export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: &#123; a:'父传子a', b:'父传子2' &#125; &#125; &#125;, components:&#123; packAge &#125; &#125;&lt;/script&gt; 3:在子组件中使用传递的参数 12345&lt;template&gt; &lt;div class=\"pack-age\"&gt; &lt;h1&gt;&#123;&#123;this.meg.a&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 下一章会讲述子向父和同级间的参数传递 var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue组件","slug":"Vue/Vue组件","permalink":"http://yoursite.com/categories/Vue/Vue组件/"}],"tags":[]},{"title":"vue-router(四)","slug":"vue-router-ËÄ","date":"2017-09-09T15:57:55.000Z","updated":"2017-11-21T15:35:46.000Z","comments":true,"path":"2017/09/09/vue-router-ËÄ/","link":"","permalink":"http://yoursite.com/2017/09/09/vue-router-ËÄ/","excerpt":"路由的重定向","text":"路由的重定向 简单的redirect重定向路由的重定向主要用在当设定的路径不一样,但我们又想让它们跳转到同一个页面的时候. 首先我们需要index.js的路由配置项中配置redirect,如下,我们设置一个gohome路径名, 123456789&#123; path: '/', // 路由路径(默认主路由路径/) name: 'HelloWorld', // 路由名称 component: HelloWorld // 对应的组件模板名称 &#125;,&#123; path:'/gohome/:myName/:lovely', redirect:'//:myName/:lovely' &#125; 这时候我们在发生如下link-to时,跳转的页面发现是首页.1&lt;router-link to=\"/gohome\"&gt;hello&lt;/router-link&gt; 这就是一个简单的vue-router的redirect重定向. redirect重定向url传参和上章写到的url传参写法是一样的,不同的点在于redirect参数要和其path一样, 1234&#123; path:'/gohome/:myName/:lovely', redirect:'/TEM1/:myName/:lovely' &#125; 参数接收方法和正常的路由接收方法一样。 alias别名使用alias和redirect的效果基本类似,不过alias是使用别名的方式来实现重定向效果. 123456&#123; path: '/TEM2/:myName/:lovely', name: 'TEM2', component: TEM2, alias: '/herf' &#125;, link-to的写法如下, 1&lt;router-link to=\"/herf\"&gt;alias&lt;/router-link&gt; 可以发现: 1&lt;router-link to=\"/TEM2\"&gt;alias&lt;/router-link&gt; 两个跳转页面是一致的. redirect和alias的区别1redirect：redirect是直接改变了url的值，把url变成了真实的path路径。 1alias：URL路径没有改变，这种情况更友好，让用户知道自己访问的路径， var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue-router","slug":"Vue/Vue-router","permalink":"http://yoursite.com/categories/Vue/Vue-router/"}],"tags":[]},{"title":"vue-rouetr(三)","slug":"vue-rouetr-Èý","date":"2017-09-08T15:58:43.000Z","updated":"2017-11-21T15:35:40.000Z","comments":true,"path":"2017/09/08/vue-rouetr-Èý/","link":"","permalink":"http://yoursite.com/2017/09/08/vue-rouetr-Èý/","excerpt":"router 路由传参","text":"router 路由传参 #####1:index.js 配置项中利用url 传参 12345&#123; path: '/TEM2/:myName/:lovely', name: 'TEM2', component: TEM2 &#125;, 在 link-to中输出参值 1&lt;router-link to=\"/TEM2/Mr.Wang/Code\"&gt;TEM1_Children1&lt;/router-link&gt; 在 TEM2页面用$router接收参数 12&lt;p&gt;&#123;&#123;$route.TEM2.myName&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;$route.TEM2.lovely&#125;&#125;&lt;/p&gt; #####2:正则表达式在 url 传值中的利用 12345&#123; path: '/TEM2/:myName(\\\\d+)/:lovely', name: 'TEM2', component: TEM2&#125;, 当我们加入\\d 的正则判断后,传递除数字外其他的参数时, TEM2.vue 是接收不到参数的.需要注意的是正则判断要写在括号内. var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue-router","slug":"Vue/Vue-router","permalink":"http://yoursite.com/categories/Vue/Vue-router/"}],"tags":[]},{"title":"vue-router(二)","slug":"vue-router-¶þ","date":"2017-09-05T15:32:21.000Z","updated":"2017-11-21T15:35:32.000Z","comments":true,"path":"2017/09/05/vue-router-¶þ/","link":"","permalink":"http://yoursite.com/2017/09/05/vue-router-¶þ/","excerpt":"router 配置子路由","text":"router 配置子路由 最近公司有一个改动比较大的新需求,所以最近比较忙,没时间更新博客,好在需求已经完成,虽然中间历经波折,还成了一代背锅侠,不过还好总算还有收获.接下来会回复正常更新,有时我也会更新一些自己感觉还可以的需求解决代码. 上章我们讲了配置路由项,其中配置路径时: 123456routes: [ &#123; path: '/', // 路由路径(默认主路由路径/) name: 'HelloWorld', // 路由名称 component: HelloWorld // 对应的组件模板名称 &#125;, 默认主路由,也就是进入页面显示的内容.其他的就是普通的路由,不控制的话,并不会在页面中显示.言归正传,这章我们讲的是子路由,首先我们要明白三点: 什么是子路由这个从名字就能看出它的含义:路由的子级路由.听一位大神说过一句话,子路由又叫菜单路由. 子路由是用来做什么的?子路由一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式.比如淘宝列表页,点击商品栏目会出现相应的商品内容. 子路由的使用方法接着上章建的文件来写,我们为 TEM1.vue 在components下新建两个子级路由,起名叫 Children1.vue 和 Children2.vue,文件内容和 TEM1.vue 一样,唯一改变的只是 msg.name 的值. 下一步就是需要在 router 下的index.js 中引入子路由页面: 1234567891011121314151617181920212223242526272829303132import Vue from 'vue' // 引入 vueimport Router from 'vue-router'import HelloWorld from '@/components/HelloWorld' // 引入 vuerouterimport TEM2 from '@/components/TEM2'import TEM1 from '@/components/TEM1'import Children1 from '@/components/Children1' //引入子路由import Children2 from '@/components/Children2' //引入子路由Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', // 路由路径(默认主路由路径/) name: 'HelloWorld', // 路由名称 component: HelloWorld // 对应的组件模板名称 &#125;, &#123; path: '/TEM2', name: 'TEM2', component: TEM2 &#125;, &#123; path: '/TEM1', component: TEM1, children: [ &#123; path: '/', component: TEM1 &#125;, //从子级路由的角度来说是主路径 &#123; path: 'Children1', component: Children1 &#125;,//路径不要'/Children1' &#123; path: 'Children2', component: Children2 &#125; ] &#125; ]&#125;) 首先我们需要引入新建的子级路由路径,然后在 routes 的 TEM1 下 用 children 数 组的方式来配置子级路由.需要注意的点已经在上附代码中标出. 然后我们需要在 TEM1.vue 中做出如下设置123456&lt;div&gt; &lt;h1&gt; &#123;&#123; msg.name &#125;&#125; &lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; //此标签代表用来接收子级路由&lt;/div&gt; 最后我们可以在app.vue 或者父级的同级路由中link-to 来查看效果,如下是在 app.vue 中引入: 1234&lt;p&gt; &lt;router-link to=\"/TEM1/Children1\"&gt;TEM1_Children1&lt;/router-link&gt; | &lt;router-link to=\"/TEM1/Children2\"&gt;TEM1_Children2&lt;/router-link&gt;&lt;/p&gt; 今天就先到这里吧,长路漫漫,唯风作伴. var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue-router","slug":"Vue/Vue-router","permalink":"http://yoursite.com/categories/Vue/Vue-router/"}],"tags":[]},{"title":"vue-router(一)","slug":"vue-router-Ò»","date":"2017-09-03T14:45:28.000Z","updated":"2017-11-21T15:35:00.000Z","comments":true,"path":"2017/09/03/vue-router-Ò»/","link":"","permalink":"http://yoursite.com/2017/09/03/vue-router-Ò»/","excerpt":"router 配置以及 router-link 跳转","text":"router 配置以及 router-link 跳转 index.js 内配置 router首先我们在components下新建 TEM1.vue 和 TEW2.vue页面,然后在 index.js 内配置路由项,如下:1234567891011121314151617181920212223242526import Vue from 'vue' // 引入 vueimport Router from 'vue-router'import HelloWorld from '@/components/HelloWorld' // 引入 vue-routerimport TEM2 from '@/components/TEM2'import TEM1 from '@/components/TEM1'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', // 路由路径(默认主路由路径/) name: 'HelloWorld', // 路由名称 component: HelloWorld // 对应的组件模板名称 &#125;, &#123; path: '/TEM2', name: 'TEM2', component: TEM2 &#125;, &#123; path: '/TEM1', name: 'TEM1', component: TEM1 &#125; ]&#125;) 需要注意的是,每次新建路由都需要在 index.js 引入路由配置,并在 routers 下用对象的形式表达出 path 和 name 以及 component. router-link 跳转导航router-link 相当于 html中的a 标签的 herf 功能,如下是TEM1.vue页面: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt; &#123;&#123; msg.name &#125;&#125; &lt;/h1&gt; &lt;p&gt; &lt;router-link to=\"/TEM2\"&gt;TEM2&lt;/router-link&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'TEM1', data () &#123; return &#123; msg: &#123; name: 'My name is TEM1' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; TEM2.vue 与 TEM1.vue 的唯一不同点就是 msg.name 值不同,用来使页面判断清晰 router-link 需要用 to 来进行导向,其中 “TEM2” 是你将要进入的页面的路由名.同样的我们在 TEM2.vue 中也进行导向设置, 1234&lt;p&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/TEM1\"&gt;TEM1&lt;/router-link&gt; &lt;/p&gt; 首页 HelloWorld.vue 导向设置如下: 123&lt;p&gt; &lt;router-link to=\"/TEM1\"&gt;TEM1&lt;/router-link&gt;&lt;/p&gt; 一个简单的页面跳转就这样完成了,给自己加油!! var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue-router","slug":"Vue/Vue-router","permalink":"http://yoursite.com/categories/Vue/Vue-router/"}],"tags":[]},{"title":"Vue(六)","slug":"Vue-Áù","date":"2017-09-02T10:04:19.000Z","updated":"2017-11-21T15:31:40.000Z","comments":true,"path":"2017/09/02/Vue-Áù/","link":"","permalink":"http://yoursite.com/2017/09/02/Vue-Áù/","excerpt":"vue-cli的安装和文件解读","text":"vue-cli的安装和文件解读 vue-cli的安装1:安装vue-cli之前我们需要安装npm(下载链接)，安装后检测npm是否安装成功，在终端输入如下，若显示版本号则说明你已经成功安装了npm。1npm -v 2: 安装vue-cli，终端输入如下：1npm install vue-cli -g 安装成功后可以终端输入 vue -V 查看版本号，-g是全局安装的意思。 3: 初始化项目，首先新建一个文件夹用来存放自己的项目，然后终端进入这个文件夹，并输入： 1vue init &lt;template-name&gt; &lt;project-name&gt; init: 用来命令初始化项目 template-name：表示模版名称，目前官方提供了五种模版， webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。 webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。 browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。 browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。 simple-一个最简单的单页应用模板。 project-name： 项目名称，自己随意命名（指自己建的文件下产生的项目文件） 开发中我们常用的是 webpack 模板, 1vue init webpack vue-router 输入上行命令后,会询问我们几个选项: Project name :此前 init 时我们写了 project-name, 在这里就不用写了,直接回车就行. Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。 Author：作者，如果你有配置git的作者，他会读取。 Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。如果你是大型团队开发，最好是进行配置。这里我进行了配置,个人建议如果不熟悉 es6语法规则请默认回车. setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。 Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。 若未报红error出错,这证明我们已经初始化好了第一步,接下来需要启动这个项目: 1cd vue-router 1npm install 1npm run dev 第一步是进入我们的 vue 项目包,第二步是安装我们的项目依赖包,第三步是运行我们的程序 vue 的项目结构123456789101112131415161718192021222324252627282930|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico |-- index.html // 入口页面|-- package.json // 项目基本信息. main.js 文件解读main.js 是整个项目的入口文件,在 src 下: 12345678910111213import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 通过import App from ‘./App’这句话引入 App.vue 文件. App.vue 文件1234567891011121314151617181920212223&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 其中 在template标签内写HTMLDom 结构;router-view标签是引入路由 script标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。 style标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说 明的是你可以用下行代码来声明这些css样式只在本模板中起作用。1&lt;style scoped&gt;&lt;/style&gt; router/index.js 路由文件123456789101112131415import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: HelloWorld &#125; ]&#125;) 我们可以看到 import HelloWorld from ‘@/components/HelloWorld’这句话， 文件引入了/components/HelloWorldvue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示HelloWorld.vue的内容。 下章会讲述 router 路由的内容. var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue(五)","slug":"Vue-Îå","date":"2017-09-02T07:30:11.000Z","updated":"2017-11-21T15:31:50.000Z","comments":true,"path":"2017/09/02/Vue-Îå/","link":"","permalink":"http://yoursite.com/2017/09/02/Vue-Îå/","excerpt":"Vue的Class及v-if,v-show","text":"Vue的Class及v-if,v-show Vue对class所有支持方法1: v-bind绑定string类型：1&lt;div :class=\" 'classA classB' \"&gt;Demo1&lt;/div&gt; 渲染后：1&lt;div :class=\" classA classB \"&gt;Demo1&lt;/div&gt; 2:v-bind绑定数据变量：1&lt;div :class=\"classA\"&gt;Demo2&lt;/div&gt; 3:v-bind绑定数据对象：1&lt;div :class=\"&#123; 'class-a': isA, 'class-b': isB&#125;\"&gt;Demo3&lt;/div&gt; 1234data: &#123; isA: false, isB: true &#125; 4:v-bind绑定data数据数组:1&lt;div :class=\"[classA, classB]\"&gt;Demo4&lt;/div&gt; 1234data: &#123; classA: 'class-a', classB: 'class-b'&#125; 5:绑定返回对象的计算属性：1&lt;div :class=\"classObject\"&gt;Demo5&lt;/div&gt; 12345678910computed:&#123; classObject: function()&#123; return true ? &#123; 'class-a': true, 'class-b': false &#125;: &#123; 'class-a': false, 'class-b': false &#125;; &#125; v-if和v-show1 . v-if 当值为 true时，显示div ，当值为false时，改元素消失，代码也会消失，相当于将代码删除了，当在为true时，页面会重新渲染div;而v-show 控制的隐藏出现，只是将css属性设为了display：none 或block; 2:v-if 后还有 v-else 和 v-else-if 条件渲染，这里需要注意的是v-else 必须紧跟 v-if 或v-else-if 下一节将要正式步入Vue了，有什么建议或想问的可以在下方留言板登录github留言。程序员没有github账号还是程序员吗。。 var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue(四)","slug":"Vue-ËÄ","date":"2017-08-30T14:34:28.000Z","updated":"2017-11-21T15:32:08.000Z","comments":true,"path":"2017/08/30/Vue-ËÄ/","link":"","permalink":"http://yoursite.com/2017/08/30/Vue-ËÄ/","excerpt":"Vue模板语法和计算属性等基础常识","text":"Vue模板语法和计算属性等基础常识 Vue 的模板语法和原生的 HTML + JavaScript 有何异同？相同点：都是根据最底层js为基础。不同点：Vue：内置指令和自定义指令，内置过滤器和自定义过滤器，支持双向数据绑定，组件化，Model+View+ViewModel的操作数据的方式。javaScript：直接操作DOM的方式。 Vue 模板语法的解析原理JavaScript 是被 V8 引擎执行的脚本语言，Vue template 是被 Vue 模板引擎执行的“类脚本”语言。涉及到编译原理，大致流程为：切词、转换、输出。(参考第二篇Object.defineProperty) 什么时候应该使用计算属性？当你想要的计算更改依赖于另一个属性时，可以使用Vue的计算属性 computed 。123456789101112var vm = new Vue(&#123; el: '#example', data: &#123; a: 1 &#125;, computed: &#123; b: function () &#123; // `this` 指向 vm 实例,b依赖于a return this.a + 1 &#125; &#125;&#125;) set和get属性在计算中也能使用，ardNum 的值会随着cardNum的值而函数变化，如下1&lt;p&gt;&#123;&#123;cardNum&#125;&#125;&lt;/p&gt; 12345678910111213141516171819202122232425var vm=new Vue(&#123; el: '#app', data: &#123; a: \"100\", ruleForm:&#123; ardNum: \"\" &#125; &#125;, computed: &#123; cardNum: &#123; get: function() &#123; return (this.ruleForm.ardNum/100); &#125;, set: function(vaule) &#123; this.ruleForm.ardNum = vaule*100; &#125;&#125;&#125;&#125;) 此时若在控制台输入:1vm.cardNum=2 则vm.ruleForm.ardNum的值会根据set函数而变成200。 计算属性缓存如何解决使用Methods方法或者设置 cache为false12345678computed: &#123; example: &#123; cache: false,//设置false关闭缓存 get: function () &#123; return Date.now() + this.msg &#125; &#125;&#125; var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue(三)","slug":"Vue-Èý","date":"2017-08-28T18:05:07.000Z","updated":"2017-11-21T15:31:30.000Z","comments":true,"path":"2017/08/29/Vue-Èý/","link":"","permalink":"http://yoursite.com/2017/08/29/Vue-Èý/","excerpt":"选项对象有哪些值可取","text":"选项对象有哪些值可取 1234567891011121314151617181920var vm = new Vue(&#123; el: '#example', data: &#123; a:1, message: '' &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt;这是一个自定义组件&lt;/div&gt;`, &#125; &#125; methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125; &#125;, a: function (val, oldVal) &#123; this.message = 'a的旧值为' + oldVal + '，新值为' + val; &#125; computed: &#123;&#125;, el：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。 data：Vue实例的数据对象，Vue将会递归data的属性并转换为getter/setter，只有data内的数据属性是响应的。但是在组件定义中，data必须声明返回数据对象的函数。因为组件可能被用来创建多个实例。 methods：方法写在其内，方法中的 this 自动绑定为 Vue 实例。 computed：vue实例的计算属性，与methods的区别是：计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。 template：一个字符串模板作为 Vue 实例的标识使用，模板将会 替换 挂载的元素。 components：在某个Vue实例中注册只有自己能使用的组件写在其内。 watch：Vue提供了一种通用的方式来观察和响应Vue实例上的数据变动 生命周期钩子：每个Vue实例在被创建之前都要经过一系列的初始化过程。在这些过程内可以自定义一些方法。 生命周期钩子beforeCreate:在实例初始化之后，数据观测(observer) 和 watcher 事件配置之前被调用。 created:实例已经创建完成之后被调用。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount:在挂载开始之前被调用 mounted:el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用 beforeUpdate:数据更新时调用 updated:组件DOM已更新完毕 beforeDestroy：实例销毁之前调用 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 大型应用工程中的组件划分大型应用工程中划分组件以基础组件和和业务组件来划分，像一些页面布局，重复利用率高的可以划分为基础组 件。像一些包含业务逻辑，含数据交互过多的划分为业务组件，业务组件内可以包含基础组件 var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue(二)","slug":"Vue-¶þ","date":"2017-08-26T08:33:31.000Z","updated":"2017-11-21T15:31:58.000Z","comments":true,"path":"2017/08/26/Vue-¶þ/","link":"","permalink":"http://yoursite.com/2017/08/26/Vue-¶þ/","excerpt":"Vue 是如何实现双向绑定的。","text":"Vue 是如何实现双向绑定的。 本篇文章会主要学习双向绑定的实现原理，并用js原生写个小例子。 首先我们需要知道Vue是用什么来实现数据劫持。 12345678910var vm =new Vue (&#123; data:&#123; obj:&#123; a:1 &#125; &#125;, created:function()&#123; console.log(this.obj) &#125; &#125;); 用Vue实现上述代码，并打开控制台，查看object会发现get和set两个属性：12345678910111213141516&#123;__ob__: Observer&#125; a (...) __ob__ Observer &#123;value: &#123;…&#125;, dep: Dep, vmCount: 0&#125; get a ƒ reactiveGetter() set a ƒ reactiveSetter(newVal) __proto__ Object Object.defineProperty( )究竟是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们要先来研究下它对应的两个描述属性get和set。12345678910111213var person=&#123;&#125;;var name= '';Object.defineProperty(person,'name',&#123; set:function(val)&#123; name=val; console.log(val)//李世杰 &#125;, get:function()&#123; return '胖人'+name+'有一个老年mac' &#125;&#125;)person.name=' 李世杰'console.log(person.name);//胖人李世杰有一个老年mac 可以发现，set是设置name属性时触发，get是读取name属性时触发。也说明了Vue是的确通过这种方法劫持数据的。 实现MVVM双向绑定的前言实现MVVM双向绑定主要包含两个方面。即数据变化更新视图，视图变化更新数据。1data &lt;========&gt; view; 数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty()对属性设置一个set函数，当数据改变了就会来触发这个函数。 所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了,接下来就是用到上一篇文章所提到的响应式了1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。以后我们会从原生js角度来模拟实现Vue的双向绑定。 var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Vue(一)","slug":"vue-one","date":"2017-08-24T18:07:10.000Z","updated":"2017-11-21T15:32:16.000Z","comments":true,"path":"2017/08/25/vue-one/","link":"","permalink":"http://yoursite.com/2017/08/25/vue-one/","excerpt":"vue作为一个广受欢迎的MVVM框架，是值得从基础理解它的。","text":"vue作为一个广受欢迎的MVVM框架，是值得从基础理解它的。 究竟它所发扬的渐进式、响应式、声明式和MVVM到底什么呢？ 渐进式：vue没有较强的主张性，其核心功能强调的是状态到界面的映射，声明式渲染。只做自己该做的事，不会影响其他。Vue在不依赖全家桶的情况下，单凭一个Vue就能跑起来整个项目，如果觉得Model共享数据不方便，可以接入Vuex，如果觉的路由不方便可以接入Vue-Router。所以Vue可以渐进的用社区提供的周边方案配一套全家桶。 响应式： 如图，把Directive中的数据依赖通过Watcher订阅在对应数据的 Observer 的 Dep 上。当数据变化时，就会触发 Observer 的 Dep 上的 notify 方法通知对应的 Watcher 的 update，进而触发 Directive 的 update 方法来更新 DOM 视图，最后达到模型和视图关联起来. 声明式：比如生命周期钩子，声明计算在computed内，声明方法在methods内等，个人理解什么操作写在什么声明方法内。 MVVM: MVVM核心的思想就是视图是状态的函数：View = ViewModel(Model)，所以当Model发生改变时，ViewModel会来操作View来怎么做，而非是自己写代码来做。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 我们这里先不讲它的实现源码，等能用的时候再去仔细思考它的实现原理，研究它的实现源码。 var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Vue基础","slug":"Vue/Vue基础","permalink":"http://yoursite.com/categories/Vue/Vue基础/"}],"tags":[]},{"title":"Git基础用法","slug":"Git»ù´¡ÓÃ·¨","date":"2017-07-19T16:08:45.000Z","updated":"2017-11-21T15:07:18.000Z","comments":true,"path":"2017/07/20/Git»ù´¡ÓÃ·¨/","link":"","permalink":"http://yoursite.com/2017/07/20/Git»ù´¡ÓÃ·¨/","excerpt":"git 提交三部曲","text":"git 提交三部曲 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理,它的优点在于: 1:适合分布式开发，强调个体。 2:公共服务器压力和数据量都不会太大。 3:速度快、灵活。 4:任意两个开发者之间可以很容易的解决冲突。 5:离线工作。 我们主要说一下 利用Git 工作时的基础步骤: 每次提交代码时,首先需要拉取分支代码,即使只有你和后端两个人,也要拉取,要养成一个好习惯,执行命令: 1git pull 拉取代码成功之后,我们需要做的就是把我们本地的代码提交到远程服务器分支,这中间需要三个步骤: 1git add --all git add 的作用是把我们要提交的文件的信息添加到索引库中,也就是暂存区中. 1git commit -m \"更改标识\" git commit 的作用是将修改从暂存区提交到本地版本库, 1git push -u origin 分支名 git push 的作用是将修改从本地版本库提交到远程服务器分支. 1git branch 分支名 git branch 是创建分支所执行的命令 1git checkout 分支名 git checkout 是切换分支所执行的命令 Git 处理冲突文件Git 使用时,冲突是避免不了的,当我们 git pull 出现冲突时,我们需要作出如下处理: 123git stash //撤销你的文件修改内容git pull //拉取仓库文件,此时你已撤销你的修改,可以正常拉取git stash pop //恢复你的修改内容 此时经过这三个步骤,你下面需要做的就是在你拉去后的文件中合并冲突,合并时要确定万无一失, 然后在执行提交三部曲的步骤就可以了. 有个小经验想分享给大家,当你在a 分支修改内容,但又没完成时,突然接到需求需要在 b 分支修改内容并提交,此时你的a分支需求正在实现中. 不能提交到 a 分支上,此时要怎么办呢,如果直接切换b分支,那自己在a 分支写的东西岂不是白写了,我们这时候就要用到 git stash这个命令. git stash 后,切换分支b,b 完成后切换到a, 执行 git stash pop, 就会恢复到你此前的修改状态. var gitment = new Gitment({ owner: 'YayaR', //比如我的叫anTtutu repo: 'YayaR.github.io', //比如我的叫anTtutu.github.io oauth: { client_id: '0bad35461e61ed11598d', //比如我的828*********** client_secret: '12a487ba3ca3646865ecfc21a3238aad77d0eb4a', //比如我的49e************************ }, }) gitment.render('container')","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[]}]}